#include "page.h"

#define PAGE_SIZE_MB 2
#define PAGE_SIZE_BYTES (PAGE_SIZE_MB * 1024 * 1024)

struct ppage physical_page_array[128]; // 128 pages, each 2mb in length covers 256 megs of memory

struct ppage *free_physical_pages_head = 0;

void init_pfa_list(void) {
  for (int i = 0; i < 128; i++) {
      physical_page_array[i].physical_addr = (void *) (i * PAGE_SIZE_BYTES);
      physical_page_array[i].next = (i < 128 - 1) ? &physical_page_array[i + 1]: 0;
      physical_page_array[i].prev = (i > 0) ? &physical_page_array[i - 1] : 0;
  }
  free_physical_pages = &physical_page_array[0];

}

struct ppage *allocate_physical_pages(unsigned int npages) {
  if (npages == 0 || free_physical_pages== 0)
      return 0;

  struct ppage *allocd_list= free_physical_pages;
  struct ppage *tail = allocd_list;

  // Move tail npages - 1 steps ahead
  for (unsigned int i = 1; i < npages && tail->next; i++) {
      tail = tail->next;
  }

  // Update free list head
  free_physical_pages = tail->next;
  if (free_physical_pages)
      free_physical_pages->prev = 0;

  // Cut off allocated list
  tail->next = 0;
  allocd_list->prev= 0;

  return allocd_list;
}

void free_physical_pages(struct ppage *ppage_list) {
  if (ppage_list == 0)
      return;

  // Find tail of the list to attach it to free list
  struct ppage *tail = ppage_list;
  while (tail->next)
      tail = tail->next;

  tail->next = free_physical_pages;
  if (free_physical_pages)
      free_physical_pages->prev = tail;

  ppage_list->prev = 0;
  free_physical_pages = ppage_list;
}
